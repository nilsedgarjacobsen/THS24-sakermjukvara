# Spring Security - Databaskoppling med UserDetailsService

## Introduktion

Nu ska vi koppla Spring Security till en riktig databas ist√§llet f√∂r att anv√§nda den genererade anv√§ndaren. Vi kommer att:
1. F√∂rst√• vad vi beh√∂ver i databasen
2. Skapa en User-entitet
3. Implementera UserDetailsService 
4. Konfigurera l√∂senordskryptering
5. Testa med riktiga anv√§ndare fr√•n databasen

## 1. Databaskrav och f√∂ruts√§ttningar

### Vad beh√∂vs i databasen?

F√∂r att Spring Security ska fungera med databas beh√∂ver vi **minst** dessa kolumner i en anv√§ndartabell:

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,        -- Unikt f√∂r inloggning
    password VARCHAR(255) NOT NULL,            -- Krypterat l√∂senord
    role VARCHAR(50) NOT NULL,                 -- Anv√§ndarens roll
    enabled BOOLEAN DEFAULT TRUE               -- Om kontot √§r aktivt
);
```

### Varf√∂r dessa kolumner?

- **`email` (UNIQUE)** ‚Üí Spring Security beh√∂ver n√•got unikt f√∂r att identifiera anv√§ndare
- **`password`** ‚Üí M√•ste vara krypterat (aldrig klartext!)
- **`role`** ‚Üí Best√§mmer vad anv√§ndaren f√•r g√∂ra (`USER`, `ADMIN`, etc.)
- **`enabled`** ‚Üí L√•ter oss inaktivera konton utan att ta bort dem

### Exempel-data:

```sql
INSERT INTO users (email, password, role, enabled) VALUES 
('user@example.com', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9P4/Yup3SbU', 'USER', true),
('admin@example.com', '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2uheWG/igi.', 'ADMIN', true);
```
*L√∂senorden ovan √§r "password" och "admin" - krypterade med BCrypt*

## 2. Skapa User-entiteten

```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private String role;
    
    @Column(nullable = false)
    private boolean enabled = true;
    
    // Konstruktorer
    public User() {}
    
    public User(String email, String password, String role) {
        this.email = email;
        this.password = password;
        this.role = role;
        this.enabled = true;
    }
    
    // Getters och Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getRole() { return role; }
    public void setRole(String role) { this.role = role; }
    
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}
```

## 3. Skapa UserRepository

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Spring Security beh√∂ver hitta anv√§ndare via email
    Optional<User> findByEmail(String email);
    
    // Praktiskt f√∂r att kolla om email redan finns
    boolean existsByEmail(String email);
}
```

## 4. Implementera UserDetailsService

Spring Security anv√§nder `UserDetailsService` f√∂r att h√§mta anv√§ndardata fr√•n databasen:

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        
        // H√§mta anv√§ndare fr√•n databas
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));
        
        // Konvertera till Spring Security's UserDetails
        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())                    // Anv√§nd email som username
                .password(user.getPassword())                 // Krypterat l√∂senord fr√•n DB
                .authorities("ROLE_" + user.getRole())       // Spring Security kr√§ver "ROLE_" prefix
                .disabled(!user.isEnabled())                 // Invertera enabled f√∂r disabled
                .build();
    }
}
```

**Viktigt:** Spring Security kr√§ver att roller har prefix `ROLE_` (t.ex. `ROLE_USER`, `ROLE_ADMIN`)

## 5. Konfigurera l√∂senordskryptering

Spring Security kr√§ver att l√∂senord √§r krypterade. Vi anv√§nder BCrypt:

```java
@Configuration
public class PasswordConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

## 6. Uppdatera SecurityConfig

Nu ska vi ber√§tta f√∂r Spring Security att anv√§nda v√•r databas ist√§llet f√∂r genererade anv√§ndare:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable());
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        
        // Anv√§nd v√•r UserDetailsService fr√•n databasen
        authProvider.setUserDetailsService(userDetailsService);
        
        // Anv√§nd BCrypt f√∂r l√∂senordsj√§mf√∂relse
        authProvider.setPasswordEncoder(passwordEncoder);
        
        return authProvider;
    }
}
```

**Vad h√§nder nu:**
- Spring Security anv√§nder din `UserDetailsServiceImpl`
- L√∂senord j√§mf√∂rs med BCrypt
- Inga fler genererade l√∂senord i konsollen!

## 7. Testdata-service (f√∂r utveckling)

Skapa en service som l√§gger in testdata n√§r applikationen startar:

```java
@Service
public class DataInitService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @PostConstruct
    public void initData() {
        // Skapa testanv√§ndare om de inte finns
        if (!userRepository.existsByEmail("user@test.com")) {
            User user = new User();
            user.setEmail("user@test.com");
            user.setPassword(passwordEncoder.encode("password123"));  // Kryptera l√∂senord
            user.setRole("USER");
            user.setEnabled(true);
            userRepository.save(user);
        }
        
        if (!userRepository.existsByEmail("admin@test.com")) {
            User admin = new User();
            admin.setEmail("admin@test.com");
            admin.setPassword(passwordEncoder.encode("admin123"));
            admin.setRole("ADMIN");
            admin.setEnabled(true);
            userRepository.save(admin);
        }
        
        System.out.println("‚úÖ Testanv√§ndare skapade:");
        System.out.println("   üë§ user@test.com / password123 (USER)");
        System.out.println("   üëë admin@test.com / admin123 (ADMIN)");
    }
}
```

## 8. Testa med Postman

Nu kan du testa med riktiga anv√§ndare fr√•n databasen:

### Test 1: Basic Auth med USER
```
GET http://localhost:8080/api/products
Authorization: Basic Auth
Username: user@test.com
Password: password123
Response: 200 OK
```

### Test 2: Basic Auth med ADMIN  
```
GET http://localhost:8080/api/admin/users
Authorization: Basic Auth
Username: admin@test.com
Password: admin123
Response: 200 OK (om endpoint till√•ter ADMIN)
```

### Test 3: Fel l√∂senord
```
GET http://localhost:8080/api/products
Authorization: Basic Auth
Username: user@test.com
Password: felaktigt
Response: 401 Unauthorized
```

## 9. Vanliga problem och l√∂sningar

### Problem 1: "Bad credentials" trots r√§tt l√∂senord
**Orsak:** L√∂senord √§r inte krypterat med BCrypt i databasen  
**L√∂sning:** Anv√§nd `passwordEncoder.encode()` n√§r du sparar l√∂senord:
```java
user.setPassword(passwordEncoder.encode("klartext-l√∂senord"));
```

### Problem 2: "User not found" trots att anv√§ndare finns
**Orsak:** Spring Security s√∂ker med email men din metod heter fel  
**L√∂sning:** Kontrollera att repository-metoden heter exakt `findByEmail(String email)`

### Problem 3: "Access denied" f√∂r ADMIN-anv√§ndare  
**Orsak:** Rollen saknar "ROLE_" prefix  
**L√∂sning:** I `loadUserByUsername()`, anv√§nd:
```java
.authorities("ROLE_" + user.getRole())  // Blir "ROLE_ADMIN"
```

### Problem 4: L√∂senord fungerar inte efter BCrypt
**Orsak:** BCrypt genererar olika hash varje g√•ng  
**L√∂sning:** Detta √§r normalt! BCrypt j√§mf√∂r automatiskt - testa bara att logga in

## 10. Databaskonfiguration (application.properties)

### F√∂r MySQL:
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/myapp
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

### F√∂r PostgreSQL:
```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/myapp
spring.datasource.username=postgres
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

### F√∂r H2 (in-memory, f√∂r testning):
```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.h2.console.enabled=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
```

## 11. Komplett projektstruktur

```
src/main/java/
‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îî‚îÄ‚îÄ User.java
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îî‚îÄ‚îÄ UserRepository.java
‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îú‚îÄ‚îÄ UserDetailsServiceImpl.java
‚îÇ   ‚îî‚îÄ‚îÄ DataInitService.java
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ SecurityConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ PasswordConfig.java
‚îî‚îÄ‚îÄ controller/
    ‚îî‚îÄ‚îÄ ApiController.java (dina befintliga controllers)
```

## Sammanfattning

Du har nu l√§rt dig att:
- ‚úÖ Skapa en anv√§ndartabell med r√§tt kolumner (email, password, role, enabled)
- ‚úÖ Implementera `UserDetailsService` f√∂r databaskoppling
- ‚úÖ Konfigurera BCrypt f√∂r s√§ker l√∂senordskryptering
- ‚úÖ Skapa testdata automatiskt vid appstart
- ‚úÖ Testa med riktiga anv√§ndare i Postman

## N√§sta steg

I n√§sta guide kommer vi att:
- Implementera rollbaserad auktorisering med `@PreAuthorize`
- Skapa endpoints f√∂r anv√§ndarregistrering
- L√§gga till mer avancerad anv√§ndarhantering
- Implementera JWT-tokens f√∂r stateless autentisering

---

**Tips:** Anv√§nd `user@test.com / password123` och `admin@test.com / admin123` f√∂r att testa din implementation!